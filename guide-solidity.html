<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><!-- Global site tag (gtag.js) - Google Analytics --><script async src="https://www.googletagmanager.com/gtag/js?id=UA-149147406-2"></script><script>window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-149147406-2');</script><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js"></script><script src="tooltips.js"></script><script src="reach-pre.js"></script><link rel="stylesheet" href="tooltips.css"><link rel="stylesheet" href="reach.css"><link rel="stylesheet" href="minted.css"><link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png"><link rel="manifest" href="/favicon/site.webmanifest"><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>3.3&nbsp;How does Reach development compare to Solidity development?</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-style.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript" src="manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9658;</a></td><td></td><td><a href="index.html" class="tocviewlink" data-pltdoc="x">Reach:<span class="mywbr"> &nbsp;</span> The Safest and Easiest DApp Programming Language</a></td></tr></table></div><div class="tocviewsublisttop" style="display: none;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="overview.html" class="tocviewlink" data-pltdoc="x">Overview</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="tut.html" class="tocviewlink" data-pltdoc="x">Tutorial</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="guide.html" class="tocviewselflink" data-pltdoc="x">Guide</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="workshop.html" class="tocviewlink" data-pltdoc="x">Workshop</a></td></tr><tr><td align="right">5&nbsp;</td><td><a href="ref.html" class="tocviewlink" data-pltdoc="x">Reference</a></td></tr><tr><td align="right"></td><td><a href="doc-index.html" class="tocviewlink" data-pltdoc="x">Index</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">&#9660;</a></td><td>3&nbsp;</td><td><a href="guide.html" class="tocviewlink" data-pltdoc="x">Guide</a></td></tr></table><div class="tocviewsublist" style="display: block;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tr><td align="right">3.1&nbsp;</td><td><a href="guide-windows.html" class="tocviewlink" data-pltdoc="x">Using Reach on Windows</a></td></tr><tr><td align="right">3.2&nbsp;</td><td><a href="guide-versions.html" class="tocviewlink" data-pltdoc="x">How does Reach use version numbers?</a></td></tr><tr><td align="right">3.3&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">How does Reach development compare to Solidity development?</a></td></tr><tr><td align="right">3.4&nbsp;</td><td><a href="guide-rpc.html" class="tocviewlink" data-pltdoc="x">Do I have to use Java<span class="mywbr"> &nbsp;</span>Script to write my frontend? What about Python, Go, or other languages?</a></td></tr><tr><td align="right">3.5&nbsp;</td><td><a href="guide-logging.html" class="tocviewlink" data-pltdoc="x">How do I add tracing logs to my Reach program?</a></td></tr><tr><td align="right">3.6&nbsp;</td><td><a href="guide-ctransfers.html" class="tocviewlink" data-pltdoc="x">What do the different kinds of consensus transfers mean? <span class="stt">publish</span>, <span class="stt">pay</span>, <span class="stt">race</span>, <span class="stt">fork</span>, <span class="stt">parallel<span class="mywbr"> &nbsp;</span>Reduce</span>?</a></td></tr><tr><td align="right">3.7&nbsp;</td><td><a href="guide-assert.html" class="tocviewlink" data-pltdoc="x">How and what to verify</a></td></tr><tr><td align="right">3.8&nbsp;</td><td><a href="guide-loop-invs.html" class="tocviewlink" data-pltdoc="x">Finding and using loop invariants</a></td></tr><tr><td align="right">3.9&nbsp;</td><td><a href="guide-deploymode.html" class="tocviewlink" data-pltdoc="x">Choosing a deployment mode</a></td></tr><tr><td align="right">3.10&nbsp;</td><td><a href="guide-timeout.html" class="tocviewlink" data-pltdoc="x">Non-<wbr></wbr>participation:<span class="mywbr"> &nbsp;</span> What it is and how to protect against it</a></td></tr><tr><td align="right">3.11&nbsp;</td><td><a href="guide-determ.html" class="tocviewlink" data-pltdoc="x">Determinism, simultaneity, and choice in decentralized applications</a></td></tr><tr><td align="right">3.12&nbsp;</td><td><a href="guide-race.html" class="tocviewlink" data-pltdoc="x">Racing non-<wbr></wbr>determinism in decentralized applications</a></td></tr><tr><td align="right">3.13&nbsp;</td><td><a href="guide-abstract.html" class="tocviewlink" data-pltdoc="x">Building decentralized abstractions</a></td></tr><tr><td align="right">3.14&nbsp;</td><td><a href="guide-browser-testing.html" class="tocviewlink" data-pltdoc="x">Testing Reach programs in the browser</a></td></tr><tr><td align="right">3.15&nbsp;</td><td><a href="guide-editor-support.html" class="tocviewlink" data-pltdoc="x">IDE/<span class="mywbr"> &nbsp;</span>Text Editor Support</a></td></tr><tr><td align="right">3.16&nbsp;</td><td><a href="guide-packages.html" class="tocviewlink" data-pltdoc="x">Sharing and discovering shared Reach packages</a></td></tr><tr><td align="right">3.17&nbsp;</td><td><a href="guide-reach.html" class="tocviewlink" data-pltdoc="x">How does Reach work?</a></td></tr><tr><td align="right">3.18&nbsp;</td><td><a href="guide-limits.html" class="tocviewlink" data-pltdoc="x">What are Reach&rsquo;s limitations?</a></td></tr><tr><td align="right">3.19&nbsp;</td><td><a href="guide-roadmap.html" class="tocviewlink" data-pltdoc="x">Reach&rsquo;s Roadmap</a></td></tr><tr><td align="right">3.20&nbsp;</td><td><a href="guide-changelog.html" class="tocviewlink" data-pltdoc="x">Reach&rsquo;s Changelog</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_2&quot;);">&#9658;</a></td><td>3.3&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">How does Reach development compare to Solidity development?</a></td></tr></table><div class="tocviewsublistbottom" style="display: none;" id="tocview_2"><table cellspacing="0" cellpadding="0"><tr><td align="right">3.3.1&nbsp;</td><td><a href="#%28part._.Solidity_.Development%29" class="tocviewlink" data-pltdoc="x">Solidity Development</a></td></tr><tr><td align="right">3.3.2&nbsp;</td><td><a href="#%28part._.Reach_.Development%29" class="tocviewlink" data-pltdoc="x">Reach Development</a></td></tr><tr><td align="right">3.3.3&nbsp;</td><td><a href="#%28part._.Conclusion%29" class="tocviewlink" data-pltdoc="x">Conclusion</a></td></tr></table></div></div></div><div class="tocsub"><div class="tocsubtitle">On this page:</div><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber">3.3.1<tt>&nbsp;</tt></span><a href="#%28part._.Solidity_.Development%29" class="tocsubseclink" data-pltdoc="x">Solidity Development</a></td></tr><tr><td><span class="tocsublinknumber">3.3.2<tt>&nbsp;</tt></span><a href="#%28part._.Reach_.Development%29" class="tocsubseclink" data-pltdoc="x">Reach Development</a></td></tr><tr><td><span class="tocsublinknumber">3.3.3<tt>&nbsp;</tt></span><a href="#%28part._.Conclusion%29" class="tocsubseclink" data-pltdoc="x">Conclusion</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="versionbox"><span class="version">0.1.3</span></div><div class="navsettop"><span class="navleft"><form class="searchform"><input class="searchbox" id="searchbox" type="text" tabindex="1" placeholder="...search docs..." title="Enter a search string to search the Reach documentation" onkeypress="return reach_DoSearch(event, this);"></form>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="guide-versions.html" title="backward to &quot;3.2 How does Reach use version numbers?&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="guide.html" title="up to &quot;3 Guide&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="guide-rpc.html" title="forward to &quot;3.4 Do I have to use JavaScript to write my frontend? What about Python, Go, or other languages?&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div><h4>3.3<tt>&nbsp;</tt><a name="(part._guide-solidity)"></a>How does Reach development compare to Solidity development?</h4><p>The Reach documentation is written from the perspective of a developer who has never done any <a href="ref-model.html#%28tech._dapp%29" class="techoutside" data-pltdoc="x"><span class="techinside">DApp</span></a> development of any kind before starting to use Reach.
However, mastering Reach development is a valuable skill for those developers with experience using tools like <a href="https://soliditylang.org">Solidity</a>.
But, when these developers read the Reach documentation, they are often at loss to see how what they&rsquo;re reading relates to what they already know.
This article attempts to bridge that gap and help Solidity-style developers understand Reach.</p><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p>For the rest of this article, when we use the term "Solidity development", we&rsquo;re referring to blockchain development without Reach and not literally only the programming language Solidity.
For example, "Solidity development" includes <a href="https://github.com/vyperlang/vyper">Vyper</a> developers, as well as users of tools like <a href="https://www.trufflesuite.com">Truffle Suite</a>, <a href="https://web3js.readthedocs.io/">web3.js</a>, and so on.
We&rsquo;re talking about a paradigm of <a href="ref-model.html#%28tech._dapp%29" class="techoutside" data-pltdoc="x"><span class="techinside">DApp</span></a> programming and not a specific tool.</p></blockquote></blockquote></blockquote><h5>3.3.1<tt>&nbsp;</tt><a name="(part._.Solidity_.Development)"></a>Solidity Development</h5><p>A great Solidity project typically includes seven components:</p><ol><li><p><span style="font-weight: bold">Protocol Design</span> &#8212;<wbr></wbr> A <a href="ref-model.html#%28tech._dapp%29" class="techoutside" data-pltdoc="x"><span class="techinside">DApp</span></a> starts with a protocol diagram, perhaps written using a pidgin <a href="https://en.wikipedia.org/wiki/Unified_Modeling_Language">UML</a> format, where a developer thinks about the state space of an application and the valid transitions in that state space.
This diagram includes annotations about typical use-cases and workflows for particular paths through the protocol.</p></li><li><p><span style="font-weight: bold">Smart Contract</span> &#8212;<wbr></wbr> A developer studies the protocol design and defines a smart contract program whose implicit state space matches the protocol.
For example, if a protocol has two nodes, <span class="stt">A</span> and <span class="stt">B</span>, connected by a transition labeled <span class="stt">f</span>, then the smart contract might have a Boolean <span class="stt">storage</span> variable with a name like <span class="stt">inA</span> and a method named <span class="stt">f</span> that checks if that variable is <span class="stt">true</span> and modifies it to be <span class="stt">false</span>&#8212;<wbr></wbr>thus <span class="stt">A</span> in the diagram corresponds to <span class="stt">inA = true</span> and <span class="stt">B</span> in the diagram corresponds to <span class="stt">inB = false</span>.
Part of the challenge of smart contract development is understanding the connection between the implicit state of the smart contract and the original protocol design.</p></li><li><p><span style="font-weight: bold">Middleware</span> &#8212;<wbr></wbr> A developer builds a library in a language like JavaScript or Go that uses an SDK like <span class="stt">web3.js</span> or <span class="stt">ethers</span> to connect to their smart contract.
This middleware is co-developed with the smart contract and duplicates details like the names of methods and their arguments.
It abstracts these details into higher-level patterns of operation that roughly correspond to the use-cases and workflows in the protocol design.</p></li><li><p><span style="font-weight: bold">Frontend</span> &#8212;<wbr></wbr> A developer builds a user interface that connects to the middleware and potentially a wallet, like MetaMask, and provides a high-level user-facing perspective on the software.
This is mostly insulated from the details of the particular protocol and contract, but is typically specialized to the consensus network, because the user interface surfaces details about the underlying network.</p></li><li><p><span style="font-weight: bold">Testing</span> &#8212;<wbr></wbr> Developers typically use tools like Truffle Suite or a developer instance of <span class="stt">geth</span> to launch a test consensus network and then build a suite of unit and end-to-end tests of their application, typically by either directly interacting with the middleware or the smart contract itself.
This same testing environment may be used to back a sample version of the frontend.</p></li><li><p><span style="font-weight: bold">Verification</span> &#8212;<wbr></wbr> High quality <a href="ref-model.html#%28tech._dapp%29" class="techoutside" data-pltdoc="x"><span class="techinside">DApps</span></a> are verified and audited for a variety of properties, from basic checking of things like integer and buffer overflows, to checking of the absence of famous attacks like reentrancy attacks, to more thorough checking of properties related to the particular domain of the application.
There are a wide variety of tools and companies that provide this kind of verification as a service and the best <a href="ref-model.html#%28tech._dapp%29" class="techoutside" data-pltdoc="x"><span class="techinside">DApps</span></a> are not deployed until they pass these tests, sometimes multiple of them.
Verification typically involves only the smart contract and the best versions often require a mechanical representation of the protocol design to analyze the behavior of the <a href="ref-model.html#%28tech._dapp%29" class="techoutside" data-pltdoc="x"><span class="techinside">DApp</span></a> across all its workflows.</p></li><li><p><span style="font-weight: bold">Deployment</span> &#8212;<wbr></wbr> Once the <a href="ref-model.html#%28tech._dapp%29" class="techoutside" data-pltdoc="x"><span class="techinside">DApp</span></a> is ready to be released, it will either be embedded in the frontend, if users are expected to launch their own independent instances of the smart contract, or it is launched a single time (perhaps as a contract factory) at a well-publicized address that might be embedded in the frontend.</p></li></ol><p>Obviously, we&rsquo;ve left out a lot of details, but this is a sketch of the typical components of Solidity-style development.
There are a huge number of options and techniques for almost each of these components, with some being dropped or minimized depending on the needs of the particular application.
For example, an extremely simple <a href="ref-model.html#%28tech._dapp%29" class="techoutside" data-pltdoc="x"><span class="techinside">DApp</span></a> might combine the middleware and frontend or embed a description of the protocol design as comments or some ASCII art in the smart contract source code.</p><h5>3.3.2<tt>&nbsp;</tt><a name="(part._.Reach_.Development)"></a>Reach Development</h5><p>Reach development includes each one of these seven components. But rather than requiring the use of a variety of different tools, the difficulties associated with each component are solved by a different aspect of Reach.</p><ol><li><p><span style="font-weight: bold">Protocol Design</span> &#8212;<wbr></wbr> As a programming language, Reach operates at a different level of abstraction than a language like Solidity.
Reach programs encode the same information that would be in the informal protocol design diagrams that often accompany smart contracts.
A Reach program specifically names the various participants in a <a href="ref-model.html#%28tech._dapp%29" class="techoutside" data-pltdoc="x"><span class="techinside">DApp</span></a> and their individual workflows as a single chronological workflow that shows how and when the various individual workflows intertwine.</p></li><li><p><span style="font-weight: bold">Smart Contract</span> &#8212;<wbr></wbr> By operating this higher-level of abstraction, Reach developers are not responsible for determining the state space of the smart contract.
Instead, the Reach compiler analyzes the structure of communication in the protocol design and derives the necessary state and transition functions.
This doesn&rsquo;t mean that Reach developers don&rsquo;t think about "consensus"; indeed, the <a href="ref-model.html#%28tech._consensus._step%29" class="techoutside" data-pltdoc="x"><span class="techinside">consensus step</span></a> is a fundamental part of a Reach program.
However, Reach developers can focus on the constraints on individual <a href="ref-model.html#%28tech._publication%29" class="techoutside" data-pltdoc="x"><span class="techinside">publications</span></a> and the consensual actions of the computation, rather than the mechanics of ensuring the smart contract is in the appropriate state and transitions to the correct next state.</p></li><li><p><span style="font-weight: bold">Middleware</span> &#8212;<wbr></wbr> Similarly, a Reach program includes a specification of the API of the middleware layer, via a <a href="ref-programs-appinit.html#%28tech._participant._interact._interface%29" class="techoutside" data-pltdoc="x"><span class="techinside">participant interact interface</span></a>.
This part of a Reach program is particular to each participant and explicitly names the points of contact between the participant workflow (embedded in the Reach program) and the frontend.
This means that Reach developers do not need to manually keep the middleware and smart contract in sync or update either as the protocol design changes: the Reach compiler does all of that for them.</p></li><li><p><span style="font-weight: bold">Frontend</span> &#8212;<wbr></wbr> Reach programs do not embed the frontend, like they embed the protocol design, smart contract, and middleware.
Reach developers design and build user interfaces just like they do in Solidity-style development, except that they tend to have an easier time, because the automatically-generated middleware layer thoroughly insulates them from the low-level details of the consensus network.
Reach developers can easily build their interface with JavaScript using the Reach standard library; soon, they will be able to use the language of their choice using the Reach RPC server.</p></li><li><p><span style="font-weight: bold">Testing</span> &#8212;<wbr></wbr> Reach facilitates testing in two ways.
First, the Reach language embeds a high-quality property-based testing system via the <code class="highlight"><a href="ref-programs-compute.html#%28reach._%28%28assert%29%29%29" class="k" data-pltdoc="x">assert</a></code> and <code class="highlight"><a href="ref-programs-compute.html#%28reach._%28%28forall%29%29%29" class="k" data-pltdoc="x">forall</a></code> primitives, which can be used in a basic way to write simple test cases.
Second, the Reach deployment tool, <span class="stt">reach run</span>, allows for the easy construction and running of automate test suites for the workflows of a <a href="ref-model.html#%28tech._dapp%29" class="techoutside" data-pltdoc="x"><span class="techinside">DApp</span></a>.
In both cases, it is not necessary for Reach developers to directly manage their own development networks or otherwise interact with the consensus networks they&rsquo;re testing with in any way.</p></li><li><p><span style="font-weight: bold">Verification</span> &#8212;<wbr></wbr> Every Reach compilation includes a thorough formal verification of the <a href="ref-model.html#%28tech._dapp%29" class="techoutside" data-pltdoc="x"><span class="techinside">DApp</span></a> using a SMT-based theorem prover.
This theorem prover verifies general properties that all programs should exhibit, such as never overflowing finite memory bounds or accessing uninitialized memory.
It verifies properties that all <a href="ref-model.html#%28tech._dapp%29" class="techoutside" data-pltdoc="x"><span class="techinside">DApps</span></a> should exhibit, such as <a href="ref-model.html#%28tech._token._linearity._property%29" class="techoutside" data-pltdoc="x"><span class="techinside">token linearity property</span></a> which guarantees that funds are not double-spent or forgotten about.
Furthermore, it verifies bespoke properties that are unique to the particular <a href="ref-model.html#%28tech._dapp%29" class="techoutside" data-pltdoc="x"><span class="techinside">DApp</span></a>, as specified with the <code class="highlight"><a href="ref-programs-compute.html#%28reach._%28%28assert%29%29%29" class="k" data-pltdoc="x">assert</a></code> primitive.</p></li><li><p><span style="font-weight: bold">Deployment</span> &#8212;<wbr></wbr> Some aspects of deployment decisions are embedded inside of Reach program, such as whether to use a contract factory or whether to have each instance of the <a href="ref-model.html#%28tech._dapp%29" class="techoutside" data-pltdoc="x"><span class="techinside">DApp</span></a> use an independent smart contract deployed by one of the participants.
Other aspects are part of the configuration of the Reach compiler, such as which consensus network will be targeted.
Still others are part of the configuration of the Reach standard library and testing infrastructure, like which wallet the middleware should connect to or which kind of development node should be launched and managed by Reach.</p></li></ol><h5>3.3.3<tt>&nbsp;</tt><a name="(part._.Conclusion)"></a>Conclusion</h5><p>In summary, a vibrant ecosystem of many tools, techniques, and traditions have grown up around the creation of <a href="ref-model.html#%28tech._dapp%29" class="techoutside" data-pltdoc="x"><span class="techinside">DApps</span></a> in the Solidity-style.
Reach leverages the experience of that ecosystem and provides a total solution that incorporates all of the different components into one environment, so that it can provide more services with high quality and lower cost by integrating them together.</p><div class="navsetbottom"><span class="navleft"><form class="searchform"><input class="searchbox" id="searchbox" type="text" tabindex="1" placeholder="...search docs..." title="Enter a search string to search the Reach documentation" onkeypress="return reach_DoSearch(event, this);"></form>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="guide-versions.html" title="backward to &quot;3.2 How does Reach use version numbers?&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="guide.html" title="up to &quot;3 Guide&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="guide-rpc.html" title="forward to &quot;3.4 Do I have to use JavaScript to write my frontend? What about Python, Go, or other languages?&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div><script src="reach-post.js"></script></body></html>