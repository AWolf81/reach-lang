#!/bin/sh

REACH=${0}
HERE=$(dirname "$(realpath "${REACH}")")

if [ "x${REACH_VERSION}" = "x" ] ; then
    # XXX maybe should be v0.1
    REACH_VERSION=v0.1.1
fi

if ! (which docker docker-compose > /dev/null 2>&1) ; then
    echo "Reach relies on an installation of docker and docker-compose"
    exit 1
fi

do_compile () {
    HS=${HERE}/hs

    # try to lint any args that are .rsh files
    for RSH in "$@"; do
      case "$RSH" in
        *.rsh)
          if [ -f "${RSH}" ]; then
            do_lint "${RSH}" || :
          fi
          ;;
      esac
    done

    # Note: shellcheck says splatting is dangerous,
    # (because what if file names have spaces),
    # but also, sh doesn't have array splicing, so... this.
    # It's a little less mix-and-match
    reachc_release () {
      stack build && \
        stack exec -- \
              reachc "$@"
    }
    reachc_prof () {
      stack build --profile --fast && \
        stack exec --profile -- \
              reachc --disable-reporting --intermediate-files "$@" +RTS -p
    }
    reachc_dev () {
      stack build --fast && \
        stack exec -- \
              reachc --disable-reporting --intermediate-files "$@"
    }

    ID=$(docker info --format '{{.ID}}' 2>/dev/null)
    if [ -z "${REACH_DOCKER}" ] && [ -d "${HS}/.stack-work" ] && (which stack > /dev/null 2>&1) ; then
        export STACK_YAML="${HS}/stack.yaml"
        export REACHC_ID=${ID}
        if [ "x${REACHC_RELEASE}" = "xY" ] ; then
          reachc_release "$@"
        elif [ "x${REACHC_PROFILE}" = "xY" ] ; then
          reachc_prof "$@"
        else
          reachc_dev "$@"
        fi
    else
        cat<<EOF | docker-compose -f - run --rm -e "REACHC_ID=${ID}" reach "$@"
version: '3'
services:
  reach:
    image: reachsh/reach:${REACH_VERSION}
    volumes:
      - $PWD:/app
EOF
    fi
}

do_init () {
  APP="$1"
  if [ "x$1" = "x" ] ; then
    APP="$(basename "$(pwd)")"
  fi
  VERBOSE=Y

  DOCKERFILE="Dockerfile"
  PACKAGE_JSON="package.json"
  DOCKER_COMPOSE_YAML="docker-compose.yaml"
  MAKEFILE="Makefile"

  if [ "x$2" = "x--temporary" ] ; then
    APP="index"
    DOCKERFILE="$DOCKERFILE.$APP"
    PACKAGE_JSON="$PACKAGE_JSON.$APP"
    DOCKER_COMPOSE_YAML="$DOCKER_COMPOSE_YAML.$APP"
    MAKEFILE=""
    VERBOSE=N
    TEMPORARY=Y
  fi

  MJS="$APP.mjs"
  RSH="$APP.rsh"

  if [ "x$VERBOSE" = "xY" ] ; then echo writing $DOCKERFILE; fi
  cat >"${DOCKERFILE}" <<EOF
FROM reachsh/runner:${REACH_VERSION}

# If your project needs more node dependencies:
# COPY package.json /app/
# RUN npm install

COPY . /app
EOF

  if [ "x$VERBOSE" = "xY" ] ; then echo writing $PACKAGE_JSON; fi
  # XXX We could optimize this by making reachsh/stdlib-app with everything except the MJS files and make the package linking/install go faster.
  cat >"${PACKAGE_JSON}" <<EOF
{
  "name": "@reach-sh/${APP}",
  "type": "module",
  "dependencies": {
    "@reach-sh/stdlib": "${REACH_VERSION}"
  },
  "author": "reach.sh",
  "license": "Apache-2.0",
  "scripts": {
    "app": "node --experimental-modules --unhandled-rejections=strict ${MJS}"
  }
}
EOF

  if [ "x$VERBOSE" = "xY" ] ; then echo writing $DOCKER_COMPOSE_YAML; fi
  if [ "x${REACH_ETH_MODE}" = "xganache" ] ; then

    cat >"${DOCKER_COMPOSE_YAML}" <<EOF
version: '3'
services:
  reach-app:
    image: reachsh/reach-app-${APP}:latest
    environment:
      - ETH_NODE_TYPE=in_memory_ganache
EOF

  else
    cat >"${DOCKER_COMPOSE_YAML}" <<EOF
version: '3'
services:
  reach-app:
    image: reachsh/reach-app-${APP}:latest
    depends_on:
      - devnet
    environment:
      - ETH_NODE_URI=http://devnet:8545
  devnet:
    image: reachsh/ethereum-devnet:${REACH_VERSION}
EOF
  fi

  if [ "x$TEMPORARY" != "xY" ] ; then
    if [ "x$VERBOSE" = "xY" ] ; then echo writing "$MAKEFILE"; fi
    # TODO: a better makefile
    cat >"${MAKEFILE}" <<EOF
.PHONY: run
run:
	reach compile "${APP}.rsh" main && \\
	  docker build -f "${DOCKERFILE}" -t "reachsh/reach-app-${APP}:latest" . && \\
	  docker-compose -f "${DOCKER_COMPOSE_YAML}" run --rm reach-app
EOF

    if [ ! -f "$RSH" ] ; then
      if [ "x$VERBOSE" = "xY" ] ; then echo writing "$RSH"; fi
      cat >"${RSH}" <<EOF
'reach 0.1';

export const main = Reach.App(
  {}, [['Alice', {}], ['Bob', {}]], (Alice, Bob) => {
    // ...
  }
);
EOF
    fi

    if [ ! -f "$MJS" ] ; then
      if [ "x$VERBOSE" = "xY" ] ; then echo writing "$MJS"; fi
      cat >"${MJS}" <<EOF
import * as stdlib from '@reach-sh/stdlib/ETH.mjs';
import * as backend from './build/${APP}.main.mjs';

(async () => {
  const startingBalance = stdlib.toWeiBigNumber('100', 'ether');

  const alice = await stdlib.newTestAccount(startingBalance);
  const bob = await stdlib.newTestAccount(startingBalance);

  const ctcAlice = await alice.deploy(backend);
  const ctcBob = await bob.attach(backend, ctcAlice);

  await Promise.all([
    backend.Alice(
      stdlib, ctcAlice,
      { ...stdlib.hasRandom }
    ),
    backend.Bob(
      stdlib, ctcBob,
      { ...stdlib.hasRandom }
    ),
  ]);

  console.log('Hello, Alice and Bob!');
})();
EOF
    fi

    GITIGNORE=".gitignore"
    if [ ! -f "$GITIGNORE" ] ; then
      if [ "x$VERBOSE" = "xY" ] ; then echo writing "$GITIGNORE"; fi
      cat >"$GITIGNORE" <<EOF
build/
EOF
    fi

  fi  # end if for non-temp file gen

}

run_ () {
  F="$1"
  shift
  docker-compose -f "$F" run --rm reach-app "$@"
}

do_run () {
    if [ "x$1" = "x" ] ; then
        APP="index"
    else
        ARG=$1
        if [ -d "$ARG" ] ; then
           ARG="$ARG/index"
        fi
        cd "$(dirname "$ARG")" || exit
        APP="$(basename "$ARG")"
        shift
    fi
    
    RSH="${APP}.rsh"
    MJS="${APP}.mjs"

    if [ "x$APP" = "x" ] ||
           ! [ -f "${RSH}" ] ||
           ! [ -f "${MJS}" ]; then
        echo "Usage: reach-run APP"
        echo "  where APP.rsh"
        echo "    and APP.mjs"
        echo "  exists in current directory."
        exit 1
    fi

    DOCKERFILE=Dockerfile.${APP}
    PACKAGE_JSON=package.json.${APP}
    DOCKER_COMPOSE_YAML=docker-compose.yaml.${APP}

    # XXX Can we add eslint on the JS?
    
    # XXX could we use an embedded Makefile-like logic to go faster when there are no changes?
    
    do_compile "${RSH}" || exit 1

    # XXX do something different if it has already been non-temporarily initted?
    do_init "$APP" --temporary

    docker build -f "${DOCKERFILE}" -t "reachsh/reach-app-${APP}:latest" .
    DOCKER_EXIT=$?

    cleanup () {
      # echo rm -f "${PACKAGE_JSON}" "${DOCKERFILE}" "${DOCKER_COMPOSE_YAML}"
      rm -f "${PACKAGE_JSON}" "${DOCKERFILE}" "${DOCKER_COMPOSE_YAML}"
    }

    if [ $DOCKER_EXIT -ne 0 ] ; then
      cleanup
      exit $DOCKER_EXIT
    fi

    run_ "$DOCKER_COMPOSE_YAML" "$@"
    cleanup
}

do_lint () {
  # XXX: make it work outside the repo
  # XXX: make it not require eslint to be installed locally
  # XXX: get it to propagate its error code if run on its own
  if command -v eslint > /dev/null 2>&1; then
    eslint \
      --config "${HERE}/eslint/.eslintrc.yaml" \
      --ext .rsh \
      --no-eslintrc \
      "$@"
  fi
}

do_usage () {
  echo "Usage: reach COMMAND"
  echo " where COMMAND is one of"
  echo "  compile --- compile an app"
  echo "  init    --- set up scaffolding for a simple app"
  echo "  run     --- run a simple app"
  echo "  upgrade --- upgrade Reach"
  echo "  update  --- update Reach Docker images"
  echo "  version --- display version"
  echo "  help    --- show this info"
}

SUBCOMMAND=$1
shift

case ${SUBCOMMAND} in
    compile)
        do_compile "$@"
        ;;
    run)
        do_run "$@"
        ;;
    init)
        do_init "$@"
        ;;
    lint)
        do_lint "$@"
        ;;
    upgrade)
        NEW=reach.$$
        curl https://raw.githubusercontent.com/reach-sh/reach-lang/master/reach -o ${NEW} && \
            chmod +x ${NEW} && \
            cp -f ${NEW} "${REACH}"
        exit 0
        ;;
    update)
        docker pull "reachsh/reach:${REACH_VERSION}"
        docker pull "reachsh/stdlib:${REACH_VERSION}"
        docker pull "reachsh/ethereum-devnet:${REACH_VERSION}"
        exit 0
        ;;
    version|--version)
        echo "reach ${REACH_VERSION}"
        exit 0
        ;;
    numeric-version|--numeric-version)
        echo "${REACH_VERSION}"
        exit 0
        ;;
    help|--help)
        do_usage
        exit 0
        ;;
    *)
        do_usage
        exit 1
        ;;
esac
