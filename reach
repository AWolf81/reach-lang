#!/bin/sh

REACH=${0}
HERE=$(dirname "$(realpath "${REACH}")")

if [ "x${REACH_VERSION}" = "x" ] ; then
    # XXX maybe should be v0.1
    REACH_VERSION=v0.1.1
fi

if ! (which docker docker-compose > /dev/null 2>&1) ; then
    echo "Reach relies on an installation of docker and docker-compose"
    exit 1
fi

do_compile () {
    HS=${HERE}/hs

    # try to lint any args that are .rsh files
    for RSH in "$@"; do
      case "$RSH" in
        *.rsh)
          if [ -f "${RSH}" ]; then
            do_lint "${RSH}" || :
          fi
          ;;
      esac
    done

    # Note: shellcheck says splatting is dangerous,
    # (because what if file names have spaces),
    # but also, sh doesn't have array splicing, so... this.
    # It's a little less mix-and-match
    reachc_release () {
      stack build && \
        stack exec -- \
              reachc "$@"
    }
    reachc_prof () {
      stack build --profile --fast && \
        stack exec --profile -- \
              reachc --disable-reporting --intermediate-files "$@" +RTS -p
    }
    reachc_dev () {
      stack build --fast && \
        stack exec -- \
              reachc --disable-reporting --intermediate-files "$@"
    }

    ID=$(docker info --format '{{.ID}}' 2>/dev/null)
    if [ -z "${REACH_DOCKER}" ] && [ -d "${HS}/.stack-work" ] && (which stack > /dev/null 2>&1) ; then
        export STACK_YAML="${HS}/stack.yaml"
        export REACHC_ID=${ID}
        if [ "x${REACHC_RELEASE}" = "xY" ] ; then
          reachc_release "$@"
        elif [ "x${REACHC_PROFILE}" = "xY" ] ; then
          reachc_prof "$@"
        else
          reachc_dev "$@"
        fi
    else
        cat<<EOF | docker-compose -f - run --rm -e "REACHC_ID=${ID}" reach "$@"
version: '3'
services:
  reach:
    image: reachsh/reach:${REACH_VERSION}
    volumes:
      - $PWD:/app
EOF
    fi
}

do_init () {
  # reach init [APP]
  # ----------
  # APP defaults to index
  # fail if $APP.mjs or $APP.rsh exist
  # write $APP.mjs and $APP.rsh

  APP="$1"
  if [ "x$APP" = "x" ] ; then
    APP=index
  else
    shift
  fi

  RSH="$APP.rsh"
  MJS="$APP.mjs"

  if [ -f "$RSH" ] ; then
    echo "$RSH already exists"
    exit 1
  fi
  if [ -f "$MJS" ] ; then
    echo "$MJS already exists"
  fi

  echo writing "$RSH"
  cat >"${RSH}" <<EOF
'reach 0.1';

export const main = Reach.App(
  {}, [['Alice', {}], ['Bob', {}]], (Alice, Bob) => {
    // ...
  }
);
EOF

  echo writing "$MJS"
  cat >"${MJS}" <<EOF
import * as stdlib from '@reach-sh/stdlib/ETH.mjs';
import * as backend from './build/${APP}.main.mjs';

(async () => {
  const startingBalance = stdlib.toWeiBigNumber('100', 'ether');

  const alice = await stdlib.newTestAccount(startingBalance);
  const bob = await stdlib.newTestAccount(startingBalance);

  const ctcAlice = await alice.deploy(backend);
  const ctcBob = await bob.attach(backend, ctcAlice);

  await Promise.all([
    backend.Alice(
      stdlib, ctcAlice,
      { ...stdlib.hasRandom }
    ),
    backend.Bob(
      stdlib, ctcBob,
      { ...stdlib.hasRandom }
    ),
  ]);

  console.log('Hello, Alice and Bob!');
})();
EOF
}

do_scaffold () {
  # reach scaffold [--isolate] [--quiet] [APP]
  # --------------
  # if next arg is --isolate, set ISOLATE flag & shift
  # if next arg is --quiet, disable VERBOSE flag & shift
  # APP is next arg, defaults to index
  # write each of the below if they do not exist
  # * .gitignore
  # * .dockerignore
  # Suffix the following file names with .$APP if ISOLATE:
  # Error if any of the below exist:
  # Write each of the below:
  # * package.yaml
  # * Dockerfile
  # * docker-compose.yaml
  # * Makefile

  # lol I hope you didn't misspell --isolate or --quiet
  # TODO: better arg parsing

  ISOLATE=false
  if [ "x$1" = "x--isolate" ] ; then
    ISOLATE=true
    shift
  fi

  VERBOSE=true
  if [ "x$1" = "x--quiet" ] ; then
    VERBOSE=false
    shift
  fi

  APP="$1"
  if [ "x$APP" = "x" ] ; then
    APP="index"
  else
    shift
  fi

  PROJ="$(basename "$(pwd)")"
  DOCKERFILE="Dockerfile"
  PACKAGE_JSON="package.json"
  DOCKER_COMPOSE_YAML="docker-compose.yaml"
  MAKEFILE="Makefile"

  if $ISOLATE ; then
    PROJ="$PROJ-$APP"
    DOCKERFILE="$DOCKERFILE.$APP"
    PACKAGE_JSON="$PACKAGE_JSON.$APP"
    DOCKER_COMPOSE_YAML="$DOCKER_COMPOSE_YAML.$APP"
    MAKEFILE="$MAKEFILE.$APP"
  fi

  MJS="$APP.mjs"
  RSH="$APP.rsh"

  if $VERBOSE ; then echo writing $DOCKERFILE; fi
  cat >"${DOCKERFILE}" <<EOF
FROM reachsh/runner:${REACH_VERSION}

# If your project needs more node dependencies:
# COPY package.json /app/
# RUN npm install

COPY . /app
EOF

  # TODO: s/lint/preapp. It's disabled because sometimes our
  # generated code trips the linter
  # TODO: ^ The same goes for js/runner_package.template.json

  if $VERBOSE ; then echo writing $PACKAGE_JSON; fi
  # XXX We could optimize this by making reachsh/stdlib-app with everything except the MJS files and make the package linking/install go faster.
  cat >"${PACKAGE_JSON}" <<EOF
{
  "name": "@reach-sh/${PROJ}",
  "type": "module",
  "dependencies": {
    "@reach-sh/stdlib": "${REACH_VERSION}"
  },
  "author": "reach.sh",
  "license": "Apache-2.0",
  "scripts": {
    "lint": "eslint --ignore-path .gitignore --ext .mjs .",
    "app": "node --experimental-modules --unhandled-rejections=strict ${MJS}"
  }
}
EOF

  SERVICE="reach-app-${PROJ}"
  IMAGE="reachsh/${SERVICE}"
  IMAGE_TAG="${IMAGE}:latest"
  if $VERBOSE ; then echo writing $DOCKER_COMPOSE_YAML; fi
  if [ "x${REACH_ETH_MODE}" = "xganache" ] ; then

    cat >"${DOCKER_COMPOSE_YAML}" <<EOF
version: '3'
services:
  ${SERVICE}:
    image: ${IMAGE_TAG}
    environment:
      - ETH_NODE_TYPE=in_memory_ganache
EOF

  else
    cat >"${DOCKER_COMPOSE_YAML}" <<EOF
version: '3'
services:
  ${SERVICE}:
    image: ${IMAGE_TAG}
    depends_on:
      - devnet
    environment:
      - ETH_NODE_URI=http://devnet:8545
  devnet:
    image: reachsh/ethereum-devnet:${REACH_VERSION}
EOF
  fi

  if $VERBOSE ; then echo writing "$MAKEFILE"; fi
  # TODO: a better makefile
  cat >"${MAKEFILE}" <<EOF
build/%.main.mjs: %.rsh
	reach compile $^ main

.PHONY: build
build: build/${APP}.main.mjs
	docker build -f ${DOCKERFILE} --tag=${IMAGE_TAG} .

.PHONY: run
run: run-${APP}

.PHONY: run-${APP}
run-${APP}: build
	docker-compose -f "${DOCKER_COMPOSE_YAML}" run --rm ${SERVICE} app \$(ARGS)

.PHONY: down
down: down-${APP}

.PHONY: down-${APP}
down-${APP}:
	docker-compose down ${SERVICE}
EOF

  GITIGNORE=".gitignore"
  if [ ! -f "$GITIGNORE" ] ; then
    if $VERBOSE ; then echo writing "$GITIGNORE"; fi
    cat >"$GITIGNORE" <<EOF
build/
node_modules/
EOF
  fi

  DOCKERIGNORE=".dockerignore"
  if [ ! -f "$DOCKERIGNORE" ] ; then
    if $VERBOSE ; then echo writing "$DOCKERIGNORE" ; fi
    cat >"$DOCKERIGNORE" <<EOF
node_modules/
EOF
  fi

}

do_unscaffold () {
  ISOLATE=false
  if [ "x$1" = "x--isolate" ] ; then
    ISOLATE=true
    shift
  fi

  VERBOSE=true
  if [ "x$1" = "x--quiet" ] ; then
    VERBOSE=false
    shift
  fi

  APP="$1"
  if [ "x$APP" = "x" ] ; then
    APP="index"
  else
    shift
  fi

  DOCKERFILE="Dockerfile"
  PACKAGE_JSON="package.json"
  DOCKER_COMPOSE_YAML="docker-compose.yaml"
  MAKEFILE="Makefile"

  if $ISOLATE ; then
    DOCKERFILE="$DOCKERFILE.$APP"
    PACKAGE_JSON="$PACKAGE_JSON.$APP"
    DOCKER_COMPOSE_YAML="$DOCKER_COMPOSE_YAML.$APP"
    MAKEFILE="$MAKEFILE.$APP"
  fi

  for file in $DOCKERFILE $PACKAGE_JSON $DOCKER_COMPOSE_YAML $MAKEFILE ; do
    if $VERBOSE ; then echo deleting $file ; fi
    rm -f $file
  done
}

run_ () {
  F="$1"
  shift
  PROJ="$1"
  shift
  docker-compose -f "$F" run --rm "reach-app-${PROJ}" "$@"
}

do_run () {
  # reach run args
  # check state of scaffolded files
  # * if none exist: scaffold in --isolate --quiet mode, set flag UNSCAFFOLD
  # * if all exist: just use the existing things
  # * if some exist: error
  # make build run
  # unscaffold if UNSCAFFOLD 

  if [ "x$1" = "x" ] ; then
    APP="index"
  else
    ARG=$1
    if [ -d "$ARG" ] ; then
      ARG="$ARG/index"
    fi
    cd "$(dirname "$ARG")" || exit
    APP="$(basename "$ARG")"
    shift
  fi

  RSH="${APP}.rsh"
  MJS="${APP}.mjs"

  if [ "x$APP" = "x" ] ||
       ! [ -f "${RSH}" ] ||
       ! [ -f "${MJS}" ]; then
    echo "Usage: reach-run APP"
    echo "  where APP.rsh"
    echo "    and APP.mjs"
    echo "  exists in current directory."
    exit 1
  fi

  # XXX Can we add eslint on the JS?

  MAKEFILE=Makefile
  DOCKERFILE=Dockerfile
  PACKAGE_JSON=package.json
  DOCKER_COMPOSE_YAML=docker-compose.yaml

  NONE_EXIST=true
  if [ -f "$MAKEFILE" ] || [ -f "$DOCKERFILE" ] || [ -f "$PACKAGE_JSON" ] || [ -f "$DOCKER_COMPOSE_YAML" ] ; then
    NONE_EXIST=false
  fi

  if $NONE_EXIST ; then
    do_scaffold --isolate --quiet "$APP"

    # Note: do_scaffold --isolate has mutated these vars like so:
    # MAKEFILE=$MAKEFILE.${APP}
    # DOCKERFILE=$Dockerfile.${APP}
    # PACKAGE_JSON=$PACKAGE_JSON.${APP}
    # DOCKER_COMPOSE_YAML=$DOCKER_COMPOSE_YAML.${APP}
  else
    NOT_ALL_EXIST=true
    if [ -f "$MAKEFILE" ] && [ -f "$DOCKERFILE" ] && [ -f "$PACKAGE_JSON" ] && [ -f "$DOCKER_COMPOSE_YAML" ] ; then
      NOT_ALL_EXIST=false
    fi

    if $NOT_ALL_EXIST ; then
      # TODO: more description on err
      echo "I'm confused, some scaffolded files exist, but not all"
      exit 1
    fi
  fi

  cleanup () {
    do_unscaffold --isolate --quiet "$APP"
  }

  if [ "x$*" = "x" ] ; then
    make -f "$MAKEFILE" build run
  else
    # Note: this has to be $* and not $@ because
    # ARGS must be one string for the Makefile.
    # TODO: escape it or something so that args don't get word split?
    make -f "$MAKEFILE" build "run-$APP" ARGS="$*"
  fi

  do_unscaffold --isolate --quiet "$APP"
  MAKE_EXIT=$?
  if [ $MAKE_EXIT -ne 0 ] ; then
    exit $MAKE_EXIT
  fi
}

do_lint () {
  # XXX: make it work outside the repo
  # XXX: make it not require eslint to be installed locally
  # XXX: get it to propagate its error code if run on its own
  if command -v eslint > /dev/null 2>&1; then
    eslint \
      --config "${HERE}/eslint/.eslintrc.yaml" \
      --ext .rsh \
      --no-eslintrc \
      "$@"
  fi
}

do_usage () {
  echo "Usage: reach COMMAND"
  echo " where COMMAND is one of"
  echo "  compile --- compile an app"
  echo "  init    --- set up source files for a simple app"
  echo "  run     --- run a simple app"
  echo "  scaffold -- set up docker scaffolding for a simple app"
  echo "  upgrade --- upgrade Reach"
  echo "  update  --- update Reach Docker images"
  echo "  version --- display version"
  echo "  help    --- show this info"
}

SUBCOMMAND=$1
shift

case ${SUBCOMMAND} in
    compile)
        do_compile "$@"
        ;;
    run)
        do_run "$@"
        ;;
    init)
        do_init "$@"
        ;;
    scaffold)
        do_scaffold "$@"
        ;;
    unscaffold)
        do_unscaffold "$@"
        ;;
    lint)
        do_lint "$@"
        ;;
    upgrade)
        NEW=reach.$$
        curl https://raw.githubusercontent.com/reach-sh/reach-lang/master/reach -o ${NEW} && \
            chmod +x ${NEW} && \
            cp -f ${NEW} "${REACH}"
        exit 0
        ;;
    update)
        docker pull "reachsh/reach:${REACH_VERSION}"
        docker pull "reachsh/stdlib:${REACH_VERSION}"
        docker pull "reachsh/ethereum-devnet:${REACH_VERSION}"
        exit 0
        ;;
    version|--version)
        echo "reach ${REACH_VERSION}"
        exit 0
        ;;
    numeric-version|--numeric-version)
        echo "${REACH_VERSION}"
        exit 0
        ;;
    help|--help)
        do_usage
        exit 0
        ;;
    *)
        do_usage
        exit 1
        ;;
esac
