<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><!-- Global site tag (gtag.js) - Google Analytics --><script async src="https://www.googletagmanager.com/gtag/js?id=UA-149147406-1"></script><script>window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-149147406-1');</script><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>3.8&nbsp;What are Reach's limitations and its future roadmap</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="racket.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-style.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><link rel="stylesheet" type="text/css" href="minted-solarizedlight-style.css" title="default"/><link rel="stylesheet" type="text/css" href="minted.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript" src="manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9658;</a></td><td></td><td><a href="index.html" class="tocviewlink" data-pltdoc="x">Reach:<span class="mywbr"> &nbsp;</span> The Safest and Easiest DApp Programming Language</a></td></tr></table></div><div class="tocviewsublisttop" style="display: none;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="overview.html" class="tocviewlink" data-pltdoc="x">Overview</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="tut.html" class="tocviewlink" data-pltdoc="x">Tutorial</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="guide.html" class="tocviewselflink" data-pltdoc="x">Guide</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="workshop.html" class="tocviewlink" data-pltdoc="x">Workshop</a></td></tr><tr><td align="right">5&nbsp;</td><td><a href="ref.html" class="tocviewlink" data-pltdoc="x">Reference</a></td></tr><tr><td align="right"></td><td><a href="doc-index.html" class="tocviewlink" data-pltdoc="x">Index</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">&#9660;</a></td><td>3&nbsp;</td><td><a href="guide.html" class="tocviewlink" data-pltdoc="x">Guide</a></td></tr></table><div class="tocviewsublistbottom" style="display: block;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tr><td align="right">3.1&nbsp;</td><td><a href="guide-windows.html" class="tocviewlink" data-pltdoc="x">Using Reach on Windows</a></td></tr><tr><td align="right">3.2&nbsp;</td><td><a href="guide-versions.html" class="tocviewlink" data-pltdoc="x">How does Reach use version numbers?</a></td></tr><tr><td align="right">3.3&nbsp;</td><td><a href="guide-assert.html" class="tocviewlink" data-pltdoc="x">How and what to verify</a></td></tr><tr><td align="right">3.4&nbsp;</td><td><a href="guide-loop-invs.html" class="tocviewlink" data-pltdoc="x">Finding and using loop invariants</a></td></tr><tr><td align="right">3.5&nbsp;</td><td><a href="guide-timeout.html" class="tocviewlink" data-pltdoc="x">Non-<wbr></wbr>participation:<span class="mywbr"> &nbsp;</span> What it is and how to protect against it</a></td></tr><tr><td align="right">3.6&nbsp;</td><td><a href="guide-determ.html" class="tocviewlink" data-pltdoc="x">Determinism, simultaneity, and choice in decentralized applications</a></td></tr><tr><td align="right">3.7&nbsp;</td><td><a href="guide-abstract.html" class="tocviewlink" data-pltdoc="x">Building decentralized abstractions</a></td></tr><tr><td align="right">3.8&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">What are Reach&rsquo;s limitations and its future roadmap</a></td></tr><tr><td align="right">3.9&nbsp;</td><td><a href="guide-reach.html" class="tocviewlink" data-pltdoc="x">How does Reach work?</a></td></tr></table></div></div></div></div><div class="maincolumn"><div class="main"><div class="versionbox"><span class="version">0.1.2</span></div><div class="navsettop"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="guide-abstract.html" title="backward to &quot;3.7 Building decentralized abstractions&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="guide.html" title="up to &quot;3 Guide&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="guide-reach.html" title="forward to &quot;3.9 How does Reach work?&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div><h4>3.8<tt>&nbsp;</tt><a name="(part._guide-limits)"></a>What are Reach&rsquo;s limitations and its future roadmap</h4><p>Today, Reach is a powerful language for build decentralized applications, as demonstrated in <a href="overview.html" data-pltdoc="x">the overview</a>, <a href="tut.html" data-pltdoc="x">the tutorial</a>, and the <a href="workshop.html" data-pltdoc="x">workshop series</a>.
However, it has a lot of potential for growth.
This section describes a few of these areas and gives brief sketches of our roadmap for directing this growth.
We welcome your contributions on <a href="https://github.com/reach-sh/reach-lang">GitHub</a> and on <a href="https://discord.gg/AZsgcXu">the Discord community</a> to helping make these improvement plans come to fruition.</p><p><div class="SIntrapara"><span style="font-weight: bold">&#8212;<wbr></wbr></span></div><div class="SIntrapara"><span style="font-weight: bold">Connectors.</span> Foremost, Reach is a <a href="ref-model.html#%28tech._consensus._network%29" class="techoutside" data-pltdoc="x"><span class="techinside">consensus network</span></a>-agnostic language, so one of our highest priorities is supporting a wide variety of platforms, including layer-2 abstractions over other layer-1 networks.
Presently, we have a robust <a href="ref-network-eth.html" data-pltdoc="x">Ethereum backend</a> and are working on an <a href="ref-network-algo.html" data-pltdoc="x">Algorand backend</a>.</div></p><p><div class="SIntrapara"><span style="font-weight: bold">&#8212;<wbr></wbr></span></div><div class="SIntrapara"><span style="font-weight: bold">Backends.</span> Presently, Reach has a robust <a href="ref-model.html#%28tech._backend%29" class="techoutside" data-pltdoc="x"><span class="techinside">backend</span></a> for JavaScript that is well-suited for client-facing applications and JavaScript servers.
However, we believe that many decentralized application developers would like to make use of languages like Go and Rust for their participants.
We are building a Go backend as a prototype of how to build a backend for a statically typed language.</div></p><p><div class="SIntrapara"><span style="font-weight: bold">&#8212;<wbr></wbr></span></div><div class="SIntrapara"><span style="font-weight: bold">Computation.</span> Reach&rsquo;s computational language is based on JavaScript and contains many of JavaScript&rsquo;s most desirable features, like <a href="ref-programs-compute.html#%28tech._arrow._expression%29" class="techoutside" data-pltdoc="x"><span class="techinside">arrow expressions</span></a> and free-form objects.
We are working on making the transition for JavaScript developers as seemless as possible by integrating more compatibility through features like binding patterns in function arguments, more specific <code class="highlight-inline"><span class="kd">import</span></code> and <code class="highlight-inline"><span class="kd">export</span></code> specifiers, syntactic sugar for <code class="highlight-inline"><span class="k">while</span></code> patterns, like <code class="highlight-inline"><span class="k">for</span></code> in JavaScript, and recursive functions (when they are in a tail-recursive set.)
We also plan to add features from typed languages, like abstract data types and pattern matching.
Similarly, we have plans to extend Reach&rsquo;s type system to be able to track more specific features of values, such as <a href="https://en.wikipedia.org/wiki/Refinement_type">refinement types</a>, <a href="https://en.wikipedia.org/wiki/Substructural_type_system">substructural types</a> to allow mutation, and arbitrary range integer types.
Finally, we have plans to allow more exotic features, like non-communicating loops with guaranteed termination, statically computable exceptions, and pay-as-you-go closures, including non-tail-recursion through closure conversion of non-contifiable continuations.</div></p><p><div class="SIntrapara"><span style="font-weight: bold">&#8212;<wbr></wbr></span></div><div class="SIntrapara"><span style="font-weight: bold">Verification.</span> Reach&rsquo;s verifier is robust in the face of many complex and interesting theorems about decentralized application behavior.
However, it does not soundly represent integer widths and not sensitive to numeric operation overflow, which causes traps on platforms like Algorand.
This is short-term work that is required before Reach should be consider safe for production.
In the longer term, we intend to introduce verification promises that constrain the eventual use of values, refine the knowledge checker to reduce false positives, verify core compiler algorithms, and introduce a model-checking-based assertion mechanism for specifying game theoretic properties of an application, such as that all state changes are Pareto improvements.</div></p><p><div class="SIntrapara"><span style="font-weight: bold">&#8212;<wbr></wbr></span></div><div class="SIntrapara"><span style="font-weight: bold">Infrastructure.</span> We intend to build a package system for Reach to allow for sharing composable decentralized applications.</div></p><p><div class="SIntrapara"><span style="font-weight: bold">&#8212;<wbr></wbr></span></div><div class="SIntrapara"><span style="font-weight: bold">Network Integration.</span> Since Reach is <a href="ref-model.html#%28tech._consensus._network%29" class="techoutside" data-pltdoc="x"><span class="techinside">consensus network</span></a>-agnostic, it is not possible for Reach programs to directly integrate with network-specific features, such as other contracts on Ethereum or <a href="https://developer.algorand.org/docs/features/asa/">standard assets</a> on Algorand.
We intend to support these through network selection options with Reach programs and a <a href="https://en.wikipedia.org/wiki/Gradual_typing">gradual typing</a>-style protection mechanism to characterize the verifiable properties of the foreign resources.</div></p><p><div class="SIntrapara"><span style="font-weight: bold">&#8212;<wbr></wbr></span></div><div class="SIntrapara"><span style="font-weight: bold">Communication.</span> Reach&rsquo;s communication language is limited to finite sets of a predetermined number of participants with deterministic choice and finite <a href="ref-model.html#%28tech._consensus._state%29" class="techoutside" data-pltdoc="x"><span class="techinside">consensus state</span></a>.
This rules out many popular decentralized application designs, like auctions (which have an arbitrary number of participants communicating non-deterministically) and tokens (which have state linear in the number of participants.)
We intend to address these issues in three phases:</div></p><ul><li><p>The introduction of inductive state through bounded induction, to ensure that arbitrary data is not communicated or stored in <a href="ref-model.html#%28tech._consensus._state%29" class="techoutside" data-pltdoc="x"><span class="techinside">consensus state</span></a>.
Bounded inductive state can be represented via <a href="https://en.wikipedia.org/wiki/Merkle_tree">Merkle trees</a> to ensure that <a href="ref-model.html#%28tech._consensus._state%29" class="techoutside" data-pltdoc="x"><span class="techinside">consensus state</span></a> remains finite.</p></li><li><p>The introduction of "participant classes", which are categories of participants that act identically.
After which, Reach will be limited to finite sets of a predetermined number of participant <span class="emph">classes</span>.</p></li><li><p>The introduction of safe non-determinism through <a href="https://en.wikipedia.org/wiki/Monoid#Commutative_monoid">commutative monoid</a> reduction, wherein a set of participants, <span class="RktInBG"><span class="hspace"></span><span class="RktIn">P</span><span class="hspace"></span></span>, may all contribute a value, <span class="RktInBG"><span class="hspace"></span><span class="RktIn">v(P)</span><span class="hspace"></span></span>, from a <a href="https://en.wikipedia.org/wiki/Monoid">monoid</a> <span class="RktInBG"><span class="hspace"></span><span class="RktIn">M</span><span class="hspace"></span></span>.
Since <span class="RktInBG"><span class="hspace"></span><span class="RktIn">S</span><span class="hspace"></span></span> is a commutative monoid, it has a combining operation <span class="RktInBG"><span class="hspace"></span><span class="RktIn">+ : S x S -&gt; S</span><span class="hspace"></span></span> such that <span class="RktInBG"><span class="hspace"></span><span class="RktIn">(a + b) + c = a + (b + c)</span><span class="hspace"></span></span> and <span class="RktInBG"><span class="hspace"></span><span class="RktIn">a + b = b + a</span><span class="hspace"></span></span>, so it is possible to combine the values in any order (i.e. non-deterministically) and arrive at the same value.
In practice, each participant will actually contribute a value, <span class="RktInBG"><span class="hspace"></span><span class="RktIn">u(P)</span><span class="hspace"></span></span> from an arbitrary set <span class="RktInBG"><span class="hspace"></span><span class="RktIn">U(P)</span><span class="hspace"></span></span> such that an operation <span class="RktInBG"><span class="hspace"></span><span class="RktIn">m(P) : U(P) -&gt; M</span><span class="hspace"></span></span> exists, so that the value computed will be <span class="RktInBG"><span class="hspace"></span><span class="RktIn">&#120564; { m(P)(u(P)) | P &#8712; participants }</span><span class="hspace"></span></span>.</p><p>This is analogous to using the so-called <a href="https://en.wikipedia.org/wiki/MapReduce">MapReduce</a> programming model, with the additional constraint of commutativity on the reduce method.</p><p>This solution indicates why non-determinism is difficult: participants must be able to submit their values without knowing the other values in flight, yet must also still reach consensus on the outcome of the computation.
Non-commutativity would be acceptable, but would be lower-performance as participants that "missed" and were not the first sender would be required to review the first value to ensure that they compute the same answer as the <a href="ref-model.html#%28tech._consensus._state%29" class="techoutside" data-pltdoc="x"><span class="techinside">consensus state</span></a>.
This "reviewing" would be observable by <a href="ref-model.html#%28tech._frontend%29" class="techoutside" data-pltdoc="x"><span class="techinside">frontend</span></a>s if they were involved in computing the initial value.</p></li></ul><p>Reach&rsquo;s communication language has other limitations for which we do not have short-term plans for removing.
For example, we do not intend to support co-inductive or cyclic state, nor expose an arbitrary consensus heap to programmers.</p><div class="navsetbottom"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="guide-abstract.html" title="backward to &quot;3.7 Building decentralized abstractions&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="guide.html" title="up to &quot;3 Guide&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="guide-reach.html" title="forward to &quot;3.9 How does Reach work?&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>