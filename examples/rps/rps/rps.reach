'reach/exe';

const isHand = Enum([ROCK, PAPER, SCISSORS]);

function _getHand() {
  const s = interact.getHand();
  const rockP = s === 'ROCK';
  const paperP = s === 'PAPER';
  const scissorsP = s === 'SCISSORS';
  assume(rockP || paperP || scissorsP);
  if (rockP) { return ROCK; }
  else if (paperP) { return PAPER; }
  else { return SCISSORS; } }
function getHand() {
  return ensure(isHand, _getHand()); }

const isOutcome = Enum([B_WINS, DRAW, A_WINS]);
function showOutcome(o) {
  require(isOutcome(o));
  if (o == B_WINS) { return 'Bob wins'; }
  else if (o == DRAW) { return 'Draw'; }
  else { return 'Alice wins'; } }

function _winner(handA, handB) {
  const validA = isHand(handA);
  const validB = isHand(handB);
  if (validA && validB) {
    return (handA + (4 - handB)) % 3; }
  else if (validA) {
    return A_WINS; }
  else if (validB) {
    return B_WINS; }
  else {
    return DRAW; } }
function winner(handA, handB) {
  return ensure(isOutcome, _winner(handA, handB)); }

function fair_if(handX, optionX, canWinX) {
  possible((handX == optionX) && canWinX); }

function fair_for_player(handX, canWinX) {
  fair_if(handX, ROCK, canWinX);
  fair_if(handX, PAPER, canWinX);
  fair_if(handX, SCISSORS, canWinX); }

function fair_game(handA, handB, outcome) {
  fair_for_player(handA, (outcome == A_WINS));
  fair_for_player(handB, (outcome == B_WINS)); }

const A = participant({
  _wagerAmount: uint256,
  _escrowAmount: uint256});

const B = participant({});

function main() {
  A.only(() => {
    const wagerAmount = declassify(_wagerAmount);
    const escrowAmount = declassify(_escrowAmount);
    interact.params(); });
  A.publish(wagerAmount, escrowAmount)
   .pay(wagerAmount + escrowAmount);
  commit();

  B.only(() => {
    interact.accepts(); });
  B.pay(wagerAmount);
  commit();

  A.only(() => {
    const _handA = getHand();
    const [_commitA, _saltA] = precommit(_handA);
    const commitA = declassify(_commitA);
    interact.commits(); });
  A.publish(commitA);
  commit();

  B.only(() => {
    const handB = declassify(getHand());
    interact.shows(); });
  B.publish(handB);
  require(isHand(handB));
  commit();

  A.only(() => {
    const saltA = declassify(_saltA);
    const handA = declassify(_handA);
    interact.reveals(); });
  A.publish(saltA, handA);
  check_commit(commitA, saltA, handA);
  require(isHand(handA));
  const outcome = winner(handA, handB);
  assert(implies(outcome == A_WINS, isHand(handA)));
  assert(implies(outcome == B_WINS, isHand(handB)));
  fair_game(handA, handB, outcome);

  const [getsA, getsB] = (() => {
    if (outcome == A_WINS) {
      return [2 * wagerAmount, 0]; }
    else if (outcome == B_WINS) {
      return [0, 2 * wagerAmount]; }
    else {
      return [wagerAmount, wagerAmount]; } })();
  transfer(escrowAmount + getsA).to(A);
  transfer(getsB).to(B);
  commit();

  interact.outcome();
  return showOutcome(outcome); }
